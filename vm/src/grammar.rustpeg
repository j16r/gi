use ast::Node;
use ast::Value;

#[export]
parse -> Box<Node>
    = _ first:expression _ rest:expression _ { Box::new(Node::Cons(first, rest)) }
    / _ e:expression _ { e }
    / whitespace* { Box::new(Node::Nil) }

expression -> Box<Node>
    = function
    / list
    / string
    / integer
    / bool
    / atom

function -> Box<Node>
    = "fn " function_identifier "(" _ args:sexpression _ ")" eol _ body:sexpression _ "end" { Box::new(Node::Lambda(args, body)) }

function_identifier -> Box<Node>
    = token:$([^( \t\r\n]+) { Box::new(Node::Atom(token.to_string())) }

list -> Box<Node>
    = "(" _ e:sexpression _ ")" { e }
    / "()" { Box::new(Node::Nil) }

sexpression -> Box<Node>
    = first:expression whitespace+ rest:sexpression {
      Box::new(Node::Cons(first, rest))
    }
    / e:expression {
      Box::new(Node::Cons(e, Box::new(Node::Nil)))
    }

bool -> Box<Node>
    = "true" { Box::new(Node::Value(Value::Bool(true))) }
    / "false" { Box::new(Node::Value(Value::Bool(false))) }

string -> Box<Node>
    = "\"" s:string_body "\"" { s }

string_body -> Box<Node>
    = token:$([^"]*) { Box::new(Node::Value(Value::U8String(token.to_string()))) }

integer -> Box<Node>
    = token:$([1-9][0-9]*) {
      Box::new(Node::Value(Value::Integer32(token.parse().unwrap())))
    }
    / token:$([0-9]) {
      Box::new(Node::Value(Value::Integer32(token.parse().unwrap())))
    }

atom -> Box<Node>
    = token:$([^) \t\r\n]+) { Box::new(Node::Atom(token.to_string())) }

whitespace
    = [ \t\r\n]

eol
    = [\r\n]
    / [\n]

_
    = whitespace*
