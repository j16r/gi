use ast::Node;
use ast::Value;

#[export]
parse -> Box<Node>
    = _ e:expression _ { e }
    / whitespace* { Box::new(Node::Nil) }

expression -> Box<Node>
    = list
    / string
    / integer
    / bool
    / atom

list -> Box<Node>
    = "(" e:sexpression ")" { e }
    / "()" { Box::new(Node::Nil) }

sexpression -> Box<Node>
    = first:expression whitespace+ rest:sexpression {
      Box::new(Node::Cons(first, rest))
    }
    / e:expression {
      Box::new(Node::Cons(e, Box::new(Node::Nil)))
    }

bool -> Box<Node>
    = "true" { Box::new(Node::Value(Value::Bool(true))) }
    / "false" { Box::new(Node::Value(Value::Bool(false))) }

string -> Box<Node>
    = "\"" s:string_body "\"" { s }

string_body -> Box<Node>
    = [^"]* { Box::new(Node::Value(Value::U8String(match_str.to_string()))) }

integer -> Box<Node>
    = [1-9][0-9]* {
      Box::new(Node::Value(Value::Integer32(match_str.parse().unwrap())))
    }
    / [0-9] {
      Box::new(Node::Value(Value::Integer32(match_str.parse().unwrap())))
    }

atom -> Box<Node>
    = [^) \t\r\n]+ { Box::new(Node::Atom(match_str.to_string())) }

whitespace
    = [ \t\r\n]

_
    = whitespace*
